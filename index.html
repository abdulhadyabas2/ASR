<!DOCTYPE html>
<html lang="ckb" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kurdish TTS Demo (Fixed Mobile & PC)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <meta name="color-scheme" content="light dark" />
  <style>
    /* simple spinner */
    .spinner { width: 18px; height: 18px; border: 2px solid #ccc; border-top-color: transparent; border-radius: 50%; animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-100 min-h-screen">
  <div class="max-w-md mx-auto p-4">
    <div class="bg-white dark:bg-gray-800 shadow-lg rounded-xl overflow-hidden">
      <div class="flex items-center justify-between px-4 py-3 border-b border-gray-200 dark:border-gray-700">
        <h1 class="text-base font-semibold">Kurdish TTS Demo</h1>
        <div class="flex items-center gap-2">
          <button id="testBeep" class="px-3 py-1.5 text-xs rounded-full bg-emerald-600 text-white">ðŸ”ˆ Test tone</button>
          <button id="clearLog" class="px-3 py-1.5 text-xs rounded-full bg-gray-200 dark:bg-gray-700">ðŸ§¹ Log</button>
        </div>
      </div>

      <div id="chat" class="p-4 space-y-4 h-96 overflow-y-auto" style="word-wrap: break-word;"></div>

      <div class="p-3 border-t border-gray-200 dark:border-gray-700 flex items-center gap-2">
        <input id="textInput" type="text" placeholder="Ù†ÙˆÙˆØ³Û•Ú©Û•Øª Ù„ÛŽØ±Û• Ø¨Ù†ÙˆØ³Û•â€¦" value="Ø³ÚµØ§Ùˆ Ù…Ù† Ø®Ø²Ù…Û•ØªÚ¯ÙˆØ²Ø§Ø±ÛŒ Ø¦Ø§Ø³Û†Ø³Û†ÙØªÙ…" class="flex-grow px-4 py-2 rounded-full border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 focus:outline-none focus:ring">
        <button id="sendBtn" class="px-4 py-2 bg-blue-600 text-white rounded-full hover:bg-blue-700 flex items-center gap-2">
          <span>Send</span>
          <span id="busy" class="hidden spinner"></span>
        </button>
      </div>
    </div>

    <details class="mt-3 bg-white dark:bg-gray-800 rounded-xl shadow border border-gray-200 dark:border-gray-700">
      <summary class="px-4 py-2 cursor-pointer select-none">Diagnostics</summary>
      <pre id="log" class="p-4 text-xs whitespace-pre-wrap"></pre>
    </details>
  </div>

  <script>
    // ======== Config ========
    const TTS_ENDPOINT = 'https://tts.bla.iq/text-to-speech-krmanji';
    const PREFERRED_FORMAT = 'mp3'; // backend should return mp3 for iOS

    // ======== Elements ========
    const chat = document.getElementById('chat');
    const textInput = document.getElementById('textInput');
    const sendBtn = document.getElementById('sendBtn');
    const busy = document.getElementById('busy');
    const logEl = document.getElementById('log');
    const clearLogBtn = document.getElementById('clearLog');
    const testBeepBtn = document.getElementById('testBeep');

    // ======== Logging ========
    function log(...args) {
      const line = args.map(x => (typeof x === 'string' ? x : JSON.stringify(x))).join(' ');
      logEl.textContent += line + '\n';
      logEl.parentElement.open = true; // auto-open on new logs
      console.log('[TTS]', ...args);
    }
    clearLogBtn.addEventListener('click', () => { logEl.textContent = ''; });

    // ======== Audio unlocking (iOS & mobile browsers) ========
    let audioUnlocked = false;
    let audioCtx = null; // WebAudio fallback

    function ensureAudioUnlocked() {
      if (audioUnlocked) return;
      try {
        // WebAudio context (resume on gesture)
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') {
          audioCtx.resume().catch(()=>{});
        }
        // Small silent play on an HTMLAudioElement also helps
        const a = new Audio();
        a.muted = true; a.playsInline = true; a.src = 'data:audio/mp3;base64,//uQZAAAAAD'; // tiny invalid stub
        a.play().catch(()=>{});
        audioUnlocked = true;
        log('Audio unlocked by user gesture.');
      } catch (e) {
        log('Audio unlock error:', e.message);
      }
    }

    sendBtn.addEventListener('click', () => { ensureAudioUnlocked(); sendMessage(); });
    textInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { ensureAudioUnlocked(); sendMessage(); } });

    // Demo: local test tone to verify device sound w/o network
    testBeepBtn.addEventListener('click', async () => {
      ensureAudioUnlocked();
      try {
        const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.connect(g); g.connect(ctx.destination);
        g.gain.value = 0.05; // quiet
        o.type = 'sine'; o.frequency.value = 880;
        o.start(); setTimeout(() => o.stop(), 400);
        log('Played local test tone. If you heard it, device audio works.');
      } catch (e) { log('Beep error:', e.message); }
    });

    // ======== UI helpers ========
    function setBusy(on) { busy.classList.toggle('hidden', !on); sendBtn.disabled = !!on; }

    function appendMessage(sender, message) {
      const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const wrapper = document.createElement('div');
      wrapper.className = sender === 'user' ? 'text-right' : 'text-left';
      wrapper.innerHTML = `
        <div class="inline-block">
          <span class="${sender==='user'?'bg-blue-600 text-white':'bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200'} inline-block px-4 py-2 rounded-lg max-w-xs break-words">${escapeHtml(message)}</span>
          <div class="text-xs text-gray-500 dark:text-gray-400 mt-1">${time}</div>
        </div>`;
      chat.appendChild(wrapper); chat.scrollTop = chat.scrollHeight;
    }

    function makeAudioBubble(sender) {
      const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const wrapper = document.createElement('div');
      wrapper.className = sender === 'user' ? 'text-right' : 'text-left';
      const container = document.createElement('div');
      container.className = 'inline-block';

      const audioEl = document.createElement('audio');
      audioEl.controls = true;
      audioEl.preload = 'auto';
      audioEl.playsInline = true;
      audioEl.setAttribute('playsinline', '');
      audioEl.setAttribute('webkit-playsinline', '');
      // optional: prevent download menu in some browsers
      audioEl.setAttribute('controlsList', 'nodownload noplaybackrate');
      container.appendChild(audioEl);

      const ts = document.createElement('div');
      ts.className = 'text-xs text-gray-500 dark:text-gray-400 mt-1';
      ts.textContent = time; container.appendChild(ts);

      wrapper.appendChild(container);
      return { container: wrapper, audio: audioEl };
    }

    function showTapToPlay(audioEl) {
      const btn = document.createElement('button');
      btn.className = 'mt-2 px-3 py-1 text-xs rounded-full bg-emerald-600 text-white hover:bg-emerald-700';
      btn.textContent = 'Ø¯Û•Ø³Øª Ø¨Ú©Û• Ø¨Û† Ù¾Û•Ø®Ø´';
      btn.onclick = async () => { try { await audioEl.play(); btn.remove(); } catch (e) { log('Tap-to-play failed:', e.message); } };
      audioEl.parentElement.appendChild(btn);
    }

    function showError(container, msg) {
      const box = document.createElement('div');
      box.className = 'mt-2 text-xs text-red-600 dark:text-red-400';
      box.textContent = msg; container.appendChild(box);
    }

    function escapeHtml(s) { return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

    // ======== Core flow ========
    async function sendMessage() {
      const text = textInput.value.trim();
      if (!text) return;
      setBusy(true);
      appendMessage('user', text);
      textInput.value = '';

      const audioBubble = makeAudioBubble('bot');
      const audioEl = audioBubble.audio;
      chat.appendChild(audioBubble.container);
      chat.scrollTop = chat.scrollHeight;

      // Start a muted play to keep iOS unlocked
      audioEl.muted = true; audioEl.autoplay = true; audioEl.playsInline = true;
      try { await audioEl.play(); } catch {}

      try {
        const { audioUrl, arrayBuffer } = await requestTTS(text);

        if (audioUrl) {
          await setAudioAndPlay(audioEl, audioUrl);
          log('Playing via <audio> src URL');
        } else if (arrayBuffer) {
          // Build blob URL for <audio>
          const blob = new Blob([arrayBuffer], { type: 'audio/mpeg' });
          const url = URL.createObjectURL(blob);
          await setAudioAndPlay(audioEl, url);
          log('Playing via <audio> blob URL');
        } else {
          throw new Error('No audio data returned from server');
        }
      } catch (err) {
        log('Audio element play failed, trying WebAudio fallbackâ€¦', err.message);
        try {
          await webAudioPlay(await refetchAsArrayBuffer(text));
          showTapToPlay(audioEl); // leave the control available
          log('Played via WebAudio fallback');
        } catch (e) {
          log('WebAudio fallback failed:', e.message);
          showError(audioBubble.container, 'Ù‡Û•ÚµÛ•ÛŒ Ù¾Û•Ø®Ø´: ' + e.message);
        }
      } finally {
        setBusy(false);
      }
    }

    async function requestTTS(text) {
      log('POST', TTS_ENDPOINT);
      const res = await fetch(TTS_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json, audio/mpeg, audio/mp3, audio/*'
        },
        body: JSON.stringify({ sentences: text, format: PREFERRED_FORMAT })
      });

      log('Status:', res.status, 'CT:', res.headers.get('content-type'));
      if (!res.ok) throw new Error('HTTP ' + res.status);

      const ct = (res.headers.get('content-type') || '').toLowerCase();

      // 1) Direct audio
      if (ct.includes('audio/')) {
        const buf = await res.arrayBuffer();
        return { audioUrl: null, arrayBuffer: buf };
      }

      // 2) JSON with various shapes
      if (ct.includes('application/json')) {
        const data = await res.json();
        log('JSON payload keys:', Object.keys(data || {}));
        if (typeof data === 'string') return { audioUrl: data };
        if (data.audio_url || data.url) return { audioUrl: data.audio_url || data.url };
        const b64 = data.audioContent || data.audio_content || data.audio;
        if (b64) {
          const buf = b64ToArrayBuffer(b64);
          return { audioUrl: null, arrayBuffer: buf };
        }
        throw new Error('Unexpected JSON payload');
      }

      // 3) Octet-stream or others â†’ treat as audio bytes
      const buf = await res.arrayBuffer();
      return { audioUrl: null, arrayBuffer: buf };
    }

    // If <audio> fails due to CORS or autoplay policies, play via WebAudio
    async function webAudioPlay(arrayBuffer) {
      const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      if (ctx.state === 'suspended') await ctx.resume();
      const audioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));
      const src = ctx.createBufferSource();
      src.buffer = audioBuffer; src.connect(ctx.destination); src.start(0);
      // stop automatically when done
    }

    // Re-fetch as bytes if server returned only a URL string
    async function refetchAsArrayBuffer(text) {
      const out = await requestTTS(text);
      if (out.arrayBuffer) return out.arrayBuffer;
      if (out.audioUrl) {
        const res = await fetch(out.audioUrl);
        return await res.arrayBuffer();
      }
      throw new Error('No audio to refetch');
    }

    function b64ToArrayBuffer(b64) {
      const bin = atob(b64);
      const len = bin.length; const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
      return bytes.buffer;
    }

    async function setAudioAndPlay(audioEl, src) {
      return new Promise((resolve, reject) => {
        const onCanPlay = async () => {
          audioEl.removeEventListener('canplay', onCanPlay);
          try {
            audioEl.muted = false;
            await audioEl.play();
            resolve();
          } catch (e) {
            showTapToPlay(audioEl);
            reject(e);
          }
        };
        audioEl.addEventListener('canplay', onCanPlay, { once: true });
        audioEl.src = src; audioEl.load();
      });
    }

    // Warn if running from file:// (browsers may block fetch or media decoding)
    if (location.protocol === 'file:') {
      log('Warning: running from file://. Please host this over http:// or https:// for CORS and media to work properly.');
    }
  </script>
</body>
</html>
